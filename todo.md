Just some ideas

## problem solving

* just code: domain logic / business logic / ui etc (how do you call it?)
* Markov Decision Process
* case-based reasoning
* data mining
* genetic algorithms
* support vector machines

## change

* version control
* versions - major minor fix

## documentation

  * requirements
  * technical docs

## cross cutting

* routing / navigation: name a specific nav. scheme

## dependencies

* dependency injection
* dependency graph https://en.wikipedia.org/wiki/Dependency_graph

* data
  * relational
  * sparse distributed
  * NoSQL

## presentation

* graphical design
* ux / ui
* menu
* search
* path, backtrack (?)
* categories

## data

* composite object
* Object-Relational Mapping
* https://en.wikipedia.org/wiki/Data_mapper_pattern
* https://en.wikipedia.org/wiki/Active_record_pattern
*
## the layer between programming paradigm and architecture

* Component based design
* Design by contract
* Object composition
* Domain driven design

## conventions

* DDD: names from the domain
* code conventions

## programming

* mutable (functional) locks -> Immutability
* dependency inversion (polymorphism)

## module

* module: cohesive combination of functions and data
* SRP

## and ...

* middleware
* software versions
* https://en.wikipedia.org/wiki/Process_driven_messaging_service
* https://en.wikipedia.org/wiki/System_prevalence
* https://en.wikipedia.org/wiki/Naked_objects
* https://en.wikipedia.org/wiki/Service_layer_pattern
* https://en.wikipedia.org/wiki/Action%E2%80%93domain%E2%80%93responder
* https://en.wikipedia.org/wiki/Interface-based_programming
* https://en.wikipedia.org/w/index.php?title=Debugging_pattern&oldformat=true
* https://en.wikipedia.org/wiki/Service_delivery_platform
*